# 가상 메모리(Virtual Memory)

> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행할 수 있도록 하는 기법

- 물리 메모리 용량을 초과하는 프로그램도 동작시킬 수 있다. (물리 메모리에 제약받지 않는다.)
- 동시에 더 많은 프로그램을 실행시킬 수 있다. (CPU 이용률과 처리율은 높아진다.)
- SWAP에 필요한 입출력 횟수가 줄어들기 때문에 프로그램들의 실행이 빠르다.
  - swapping : CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고 다음 프로세스의 메모리를 불러오는 기법
- 논리 메모리를 물리 메모리로부터 분리해준다.
- 시스템 라이브러리가 여러 프로세스 사이에 공유될 수 있도록 한다. 각 프로세스는 공유 라이브러리를 통해 통신할 수 있다.

* 가상 메모리를 관리하는 기법으로 **세그먼테이션(Segmentation) 기법**과 **페이징(Paging) 기법**이 있다.

</br>

## 세그먼테이션(Segmentation) 기법

> 가상 메모리를 서로 크기가 다른 세그먼트(segment, 논리적 블록 단위)로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다.

- 논리 블록을 필요에 따라 다른 크기로 할당한다.
- 미리 분할하지 않고 메모리를 사용할 시점에 할당된다.

</br>

## 페이징(Paging) 기법

> 세그먼테이션과 가상 메모리를 고정된 크기로 나누어 메모리를 관리하는 것이다.

- 불연속적인 메모리 요청 등에 유연하게 처리할 수 있다.
- 외부 단편화를 없앨 수 있다.

</br>

## 요구 페이징(Demand Paging)

> 프로그램 전체를 물리 메모리에 적재하지 않고 초기에 필요한 것들만 적재하는 전략으로 가상 메모리 시스템에서 많이 사용된다.

- 가상 메모리는 대게 페이지로 관리되는데, 요구 페이징을 사용하는 가상 메모리에서는 실제로 필요해질 때 페이지가 적재된다.
- 한 번도 접근되지 않는 페이지는 물리 메모리에 전혀 적재되지 않는다.
- 프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리된다.
  - pager : 프로세스 전체를 swap-in 하는 대신 실제 필요한 페이지들만 메모리로 읽어 온다. (불필요한 페이지를 가져오지 않음으로 시간과 메모리 공간 절약)

</br>

## 페이지 교체 알고리즘(Page Replacement Algorithm)

> 요구 페이징을 통해 프로그램 전체가 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에서 페이지 부재(page fault)가 발생하면 원하는 페이지를 보조 저장장치에서 가져와야 한다. 이때 물리 메모리가 모두 사용 중인 상황이라면 페이지 교체가 이뤄져야 한다.

</br>

### 페이지 교체 동작 순서

1. 페이지 부재(page fault)가 발생하면 디스크에서 요청된 페이지의 위치를 찾는다.
2. 물리적 메모리에서 빈 페이지 프레임을 찾는다.
   - 이때 빈 프레임이 없다면 **페이지 교체 알고리즘**을 통해 쫓아낼 페이지를 결정하고, 디스크에 기록한다.
3. 비워진 페이지 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스를 재시작한다.

</br>

### 최적(OPT, Optimal) 페이지 교체

> 앞으로 가장 오랫동안 사용하지 않을 페이지를 찾아 교체한다.

- 장점
  - 가장 낮은 페이지 부재율을 보인다.
- 단점
  - 프로세스가 앞으로 어떤 메모리를 참조할 것인지를 미리 알고 있다는 전제하에 알고리즘을 운영하므로 현실적으로 구현이 어렵다.

</br>

### FIFO(First In First Out) 페이지 교체

> 페이지 교체 시 물리 메모리에 먼저 들어왔던 페이지를 우선하여 내쫓는다.

- 장점
  - 구현하기 쉽다.
- 단점
  - 빌레이디의 모순(Belady's Anomaly)이 발생할 수 있다.
    - Belady's Anomaly : 프로세스의 프레임 수를 증가시켜줬음에도 페이지 부재율이 줄어들지 않고 증가하는 현상
  - 페이지의 향후 참조 가능성을 고려하지 않는다. (처음부터 활발하게 사용되는 페이지일 수도 있다.)

</br>

### LRU(Least Recent Used) 페이지 교체

> 마지막 참조 시점이 가장 오래된 페이지를 찾아 교체한다.

- OPT 알고리즘의 근사 알고리즘이다.

* 시간 지역성(temporal locality)을 고려해 고안된 알고리즘이다.
  - temporal locality : 최근에 사용된 데이터나 명령이 다시 사용될 확률이 높다.
* 대체로 FIFO 알고리즘보다 우수하고, OPT 알고리즘보다는 그렇지 못한 모습을 보인다.

* 장점
  - 빌레이디의 모순(Belady's Anomaly) 형상을 야기하지 않는다.
* 단점
  - 계수기(Counter)나 스택(Stack)과 같은 별도의 하드웨어가 필요하다.
  * 페이지의 최근 참조 시각을 소프트웨어적으로 유지해야 하므로 알고리즘의 운영에 overhead가 발생한다.
  * 구현이 어렵다.

</br>

### LFU(Least Frequently Used) 페이지 교체

> 참조 횟수가 가장 적은 페이지를 찾아 교체한다.

- 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정하에 고안된 알고리즘이다.

- 장점
  - LRU 알고리즘보다 오랜 시간 동안의 참조 기록을 반영할 수 있다. (장기적인 시간 규모에서의 참조 성향을 고려)
- 단점
  - 프로세스가 다른 기능을 사용하게 되면서 많이 쓰던 페이지를 더는 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다.
  - 페이지의 참조 횟수를 소프트웨어적으로 유지해야 하므로 알고리즘의 운영에 overhead가 발생한다.
  - LRU보다 구현이 복잡하다.
  - OPT 알고리즘을 제대로 근사하지 못하기 때문에 잘 쓰이지 않는다.

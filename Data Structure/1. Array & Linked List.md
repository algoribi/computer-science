# 배열(Array)

> 배열이 나란히 연결되어 하나의 연속된 집합으로서 데이터를 보관하고 있다. 따라서 논리적인 순서와 물리적인 순서가 같다.

- 크기가 고정되어 있음으로 크기를 미리 알아야 한다.
- 데이터 insert/delete에 비용이 든다.
- 빈 원소(Element)와 중복 원소(Element)가 허용된다.

* Access : index를 이용하여 데이터 검색 시 순차적 접근이 아닌 랜덤엑세스(Random Access)가 가능하다. 따라서 시간복잡도는 **O(1)**이다.
* Search : 순차 탐색에서 최악의 경우(찾고자 하는 원소가 가장 마지막에 위치한 경우) **O(n)**이 된다.
* Insert/Delete : 데이터 삽입/삭제 시 동작할 index 뒤에 데이터가 있는 경우 해당 index부터 제일 마지막 데이터의 배열을 하나씩 뒤로 혹은 앞으로 이동해야 하므로 최악의 경우 시간복잡도가 **O(n)**이 된다.

</br>

# 연결 리스트(Linked List)

> 이전/다음 node의 정보를 가지고 있어 각자의 node가 서로 연결되어 있다. 따라서 논리적인 순서와 물리적인 순서가 달라서 항상 처음 데이터부터 찾는다.

- 크기가 유동적이므로 크기를 미리 몰라도 된다.
- 데이터의 insert/delete에 용이하다.
- 중복 원소(Element)는 허용되지만, 빈 원소(Element)는 허용되지 않는다. (단 값에 NULL을 넣을 수 있음)

* Access : 연결 리스트는 순차접근만 가능하므로 최악의 경우 시간복잡도는 **O(n)**이 된다.
* Search : 제일 처음 node부터 하나씩 가야 하므로 최악의 경우 **O(n)**이 된다.
* Insert/Delete : 연결 리스트는 이전/다음 node의 정보만 계승하면 되므로 삽입/삭제를 O(1)만에 해결할 수 있다. 하지만 첫 번째 원소부터 원하는 위치까지 순차적으로 찾아가야 하므로 **O(n)**의 시간복잡도를 갖는다.

</br>

## Array VS Linked List

|                       Array                        |                    Linked List                     |
| :------------------------------------------------: | :------------------------------------------------: |
|              검색이 빈번할 경우 선택               |           삽입과 삭제가 빈번할 경우 선택           |
|                 Random Access 지원                 | Random Access를 지원하지 않으며 순차적 접근이 필요 |
| 데이터의 삽입/삭제에 후미의 데이터들의 이동이 필요 |  데이터들의 이동 없이 인접 데이터들의 정보만 수정  |
|          공간이 모자랄 경우 Resizing 필요          |           필요할 때마다 노드를 생성/제거           |

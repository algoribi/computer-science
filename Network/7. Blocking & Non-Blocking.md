# Blocking I/O & Non-Blocking I/O

> I/O(Input/Output) 작업은 유저 레벨에서 직접 수행할 수 없고 커널 레벨에서만 수행이 가능하다. 따라서 유저 프로세스(또는 스레드)는 커널에 I/O를 요청해야 한다.

## Blocking I/O

1. 유저 프로세스(또는 스레드)가 커널에 I/O를 요청하는 함수를 호출한다.
2. 커널이 작업을 완료하면 함수가 작업 결과를 반환한다.

- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단하고 대기해야 한다.
- I/O 작업이 CPU 자원을 거의 쓰지 않아 리소스(Resource) 낭비가 심하다.
- 여러 클라이언트가 접속하는 서버를 Blocking 방식으로 구현하는 경우 클라이언트별로 별도의 스레드를 만들어줘야 한다.
- 스레드가 많으면 CPU의 문맥 교환 횟수가 증가할 것이며, 실제 작업하는 양에 비해 훨씬 비효율적으로 동작하게 되는 문제가 있다.

</br>

## Non-Blocking I/O

> Blocking 방식의 비효율성을 극복하고자 만들어졌다.

1. 유저 프로세스(또는 스레드)가 커널에 I/O를 요청하는 함수(recvfrom)를 호출한다.
2. 함수는 I/O를 요청한 다음 진행 상황과 상관없이 바로 결과를 반환한다.
   - 커널이 I/O를 요청받아 데이터를 받는 중에 recvBuffer가 비어있다면 받아올 수 있는 정보가 없음으로 아직 작업을 진행 중이라는 의미로 "EWOULDBLOCK"을 리턴한다. 이 결과를 받은 유저 프로세스는 다른 작업을 진행할 수 있다.
   - recvBuffer에 유저가 받을 수 있는 데이터가 있다면, 버퍼로부터 데이터를 복사하여 받아온다. 이때 recvBuffer는 커널이 가지고 있는 메모리에 적재되어 있음으로 메모리 간 복사가 일어나 훨씬 빠른 속도로 데이터를 받아올 수 있다.

- I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다.

## 스마트 포인터

- 기존 포인터의 메모리 누수를 해결하기위해 c++11부터 생김

  > 특정 스코프 내에서 선언한 객체는 스코프 범위를 벗어나게 되면 메모리가 자동으로 해제되지만, 동적 할당으로 선언 된 객체는 스택이 아닌 힙영역에 할당되기 때문에 스코프를 벗어나더라도 계속 유지된다. 따라서 프로그래머가 동적 할당한 객체에 대해 메모리 해제를 하지 않으면 메모리 누수 문제가 발생한다.

- unique_ptr : '고유 소유권', 따로 delete 하지 않아도 스택 메모리에서 벗어날때 자동으로 가지고 있던 힙메모리 소멸, std::move로만 소유권을 넘길 수 있음, nullptr로 수동 소멸 가능
- shared_ptr : '참조 카운팅', 여러개의 개체가 하나의 포인터 공유, 참조 개체가 늘어날때마다 카운팅해서 0이되면 힙에서 메모리 해제, 순환참조시 문제 발생
- weak_ptr : 순환참조 해결, shared_ptr의 참조가 끊어지면 연관된 weak_ptr도 끊어짐

* 가비지 콜렉션 : 동적으로 할당한 메모리를 더이상사용하지 않을때 회수 하는것
  자바는 자동, C++은 없기 때문에 스마트포인터를 이용

## 메모리 관리

- 스택과 힙을 그림으로 표현할 줄 알아야 한다. 내부 메커니즘을 이해하는 데 도움이 되기 때문이다.
- 로우레벨 메모리 할당 및 해제 함수의 사용을 자제합시다. 요즘은n ew, delete, new[], delete[], malloc(), free()와 같은 함수를 직접 호출하지 않고 스마트 포인터를 사용하는 추세이다.
- 스마트 포인터를 제대로 이해해야 한다. std::unique_ptr를 기본으로 사용하고, 공유할 대상은 shared_ptr로 표현한다.
- std::unique_ptr는 std::make_unique()로 생성한다.
- std::shared_ptr는 std::make_shared()로 생성한다.
- 이미 폐기됐고 C++17부터는 완전히 삭제된 std::auto_ptr는 절대로 사용하지 않는다.
- 로우레벨 메모리 할당 함수를 굳이 사용해야 한다면 malloc()이나 free()보다는 new, delete, new[], delete[]를 사용한다.
- 객체를 가리키는 포인터 배열을 사용할 때는 각 원소에 있는 포인터마다 메모리를 할당하고 해제해야 한다. 배열 할당 구문은 포인터까지 처리해주지 않는다.
- 메모리 할당 문제를 검사해주는 도구(예: 밸그라인드)를 이용하면 메모리 문제를 쉽게 찾을 수 있다는 것도 알아두면 좋다.

## 면접 질문

- C++에는 이렇게 알아서 메모리 관리를 해주는 가비지콜렉션이 없는데 안전하게 메모리를 해제하려면 어떻게 해야할까요?

  > 스마트 포인터를 사용

- 만약 어쩔 수 없이 스마트 포인터 대신 로우레벨의 메모리 할당 함수(malloc나 new)를 사용해야 한다면 무엇을 사용하시겠습니까? 그 이유는?
  > 이왕이면 new, delete 를 사용해라. 메모리 해제 방식(delete -> 이펙티브 설계 및 선언 파트를 보면(p 143 IDE) 인터페이스를 설계할 때는 일관적인 인터페이스를 제공할 수 있어야 한다.(ex. c++의 STL의 컨테이너들의 경우 대부분 일관성을 가지고 있음))

### new도 사실 내부적으로는 malloc를 통해 구현되어 있다. (다만 그 size가 const로 보호받고 있다.)

> 사실 c++에서 사용되는 것 중 c에서 없던 기능이라면 내부적으로 C를 통해 구현되어 있을 확률이 높다.

### new와 malloc의 동작원리

> https://woo-dev.tistory.com/123

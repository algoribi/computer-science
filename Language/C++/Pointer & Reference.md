# Pointer(포인터) & Reference(레퍼런스:참조자)

> Pointer와 Reference는 C++이 다른 언어와 큰 차이점을 가지는 지점이다. 바로 Pointer와 Reference를 이용해 메모리를 직접 핸들링 할 수 있기 때문이다. Pointer의 경우 C에도 있는 개념이지만 Reference는 C++에서 등장한 개념이다. 둘은 용도가 비슷해 보이는 데 어떤 차이가 있으며 Reference가 왜 등장하게 됐는지 알아보자.

</br>

## Pointer(포인터)

> 메모리의 주소값을 저장하는 변수이다.

```cpp
    // 문법 예제
    int a = 10; // 변수 선언
    int *ptr = &a; // 포인터 선언 // 주소 연산자(&)를 통해 주소값을 할당
    char *ptr1, *ptr2; // 여러 개의 포인터를 동시에 선언
    // 다음의 코드는 모두 정상적인 포인터 선언 방법이다.
    int* p1;
    int *p2;
    int*p3;
    int * p4;
```

- 포인터는 선언과 동시에 초기화하지 않아도 되지만 사용하기 전에는 반드시 초기화되어야 한다. 초기화하지 않은 채로 값을 참조(\*)하여 사용하게 되면 알 수 없는 메모리 장소에 값을 저장하게 되기 때문이다.

</br>

## Reference(레퍼런스:참조자)

> 이미 선언된 변수에 "별명"을 붙이는 것이다.

```cpp
    // 문법 예제
    int a = 10; // 변수 선언
    int& ref = a; // 참조자 선언 // 대상을 직접 할당
```

- 선언과 동시에 반드시 초기화되어야 한다.
- 한 번 초기화하면, 참조하는 대상을 변경할 수 없다.

```cpp
    int& ref1 = 5; // Error
    const int& ref2 = 5; // OK
```

- 레퍼런스는 상수를 참조할 수 없지만 const를 선언하게 되면 상수 값도 참조할 수 있다. 프로그램상에서 변수명이 없는 임시 변수에 이 상수 값을 저장하고, 그 임시 변수를 레퍼런스가 참조하게 되면서 별명을 얻게 된다. const로 선언되었기 때문에 값의 변경은 불가능하다.

</br>

## Pointer(포인터)와 Reference(레퍼런스:참조자)의 차이점

- 포인터는 NULL 값을 허용하지만, 레퍼런스는 NULL이 허용되지 않는다. 이는 참조 대상을 할당하는 방법에서 오는 차이라고도 볼 수 있는데, 포인터는 참조 대상에 대해 주소 연산자(&)를 통해 주소값을 할당받지만 레퍼런스는 대상을 직접 할당받기 때문이다. 또한 레퍼런스는 선언과 동시에 반드시 초기화되어야 한다. 따라서 레퍼런스는 애초에 NULL을 할당할 수 없다.
- 포인터는 고유한 주소를 갖지만, 레퍼런스는 기존 변수가 가지는 또 다른 이름인 별명이므로 메모리를 따로 갖지 않는다. int \*ptr = &a;에서 ptr의 주소는 a의 주소와는 다르다. 하지만 레퍼런스의 경우 int& ref = a;에서 ref와 a의 주소는 같다. 즉 레퍼런스가 가리키는 오브젝트와 같은 주소값을 가진다.
- 포인터는 int \*ptr[10];과 같이 배열로 만들 수 있다. 레퍼런스는 불가능하다.

</br>

## 결론

사실 레퍼런스와 포인터의 작동을 어셈블리어로 변환하면 내부적인 작동의 차이점이 없음을 알 수 있다. 다만 둘의 특징에서 보았듯이 레퍼런스는 포인터를 사용할 때 생기는 위험한 상황들을 미연에 방지하여 포인터로 인해 발생할 수 있는 문제들을 최소화하기 위해 만든 개념이라고 볼 수 있다.
실제로 [C++ FAQ](https://isocpp.org/wiki/faq/references)의 레퍼런스 항목에서

> When should I use references, and when should I use pointers?
> 레퍼런스는 언제 사용해야 하고, 포인터는 언제 사용해야 하나요?

라는 질문에

> Use references when you can, and pointers when you have to.
> 가능한 경우 레퍼런스를 사용하고, 필요한 경우 포인터를 사용하라.

라고 설명되어 있다.

### 번외 : 함수 호출 방식

- call by value : 매개변수가 원본값을 복사하여 가지고 온다. 따라서 원본값에 영향을 주지 않아 안전하지만, 메모리 사용량이 늘어난다.
- call by address : 매개변수가 포인터 변수를 만들고, 그 포인터 변수가 원본을 가리킴으로써(address) 원본값에 접근해 변경이 가능하다. 그러나 이 경우 포인터의 증감을 통해 다른 주소에 접근하는 것처럼 메모리에 직접적인 접근이 가능하다는 문제가 있다.
- call by reference : 매개변수가 원본의 메모리 자체를 참조하게 된다. 따라서 원본의 값에 바로 접근할 수 있다.

### 번외 : 이중 레퍼런스? 레퍼런스에 대한 포인터?

- 포인터는 **ptr, \***ptr과 같이 이중, 삼중 포인터를 만드는 것이 가능하다. 그렇다면 이중 레퍼런스를 만드는 것 또한 가능할까? 답은 불가능이다. 레퍼런스의 경우, 레퍼런스 자체로 이미 어떤 변수에 대한 별명인데, 별명에 별명을 또 만들 필요가 없기 때문이다. 따라서 이러한 기능은 쓸모가 없어서 지원하지 않는다. 같은 이치로 레퍼런스에 대한 포인터 또한 문법을 지원하지 않는다. 레퍼런스가 이미 "별명"이기 때문에 굳이 레퍼런스에 대한 포인터를 만들 바에 레퍼런스가 가리키는 원본 값에 대한 포인터를 선언하는 쪽이 합리적이기 때문이다.

# TCP 흐름제어 & 혼잡제어

## TCP(Transmission Control Protocol) 통신

> 신뢰성 있는 전송제어 프로토콜

- TCP에서 데이터의 단위는 세그먼트(Segment)이다.
- TCP는 기본적으로 IP와 함께 사용된다.
- TCP는 unreliable network에서, reliable network를 보장할 수 있도록 하는 프로토콜이다.
  - reliable network를 보장하는 것 : 패킷의 손실, 순서 바뀜, 네트워크의 혼잡 문제, receiver가 overload 되는 문제를 보장한다는 것이다.
  - 이런 특성으로 인해 신뢰성 있는 프로토콜이라고 한다.

</br>

## 흐름제어(Flow Control)

> 호스트(송신 측)와 호스트(수신 측) 간의 데이터처리 속도 차이를 해결하기 위한 기법이다.

- 송신자의 데이터 전송 속도가 수신자의 데이터 처리 속도보다 빠를 경우 심각한 문제가 발생할 수 있다.
  - 이럴 경우 수신자는 버퍼를 통해 데이터를 저장한다. 하지만 큐가 꽉 찼는데도 송신자가 계속 데이터를 전송한다면 그대로 데이터 손실이 일어난다.
  - 이러한 손실을 방지하기 위해 송신 측의 데이터 전송량을 수신 측에 따라 조절해야 한다.

### 1. Stop and Wait

    > 전송한 패킷에 대해 매번 확인 응답을 받아야 다음 패킷을 전송하는 방법

    - Stop and Wait은 일정 시간 동안 한 개의 Frame밖에 보내지 못하기 때문에 효율성을 개선하고자 나온 방법이 Sliding-Window이다.

### 2. Sliding-Window

    > 수신 측에서 설정한 윈도우(Window) 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법

    - Window : TCP/IP를 사용하는 모든 호스트는 송신과 수신을 위한 두 개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 3 Way-Handshake를 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.

    <img src="img/sliding_window.png">

    1. 송신 측은 윈도우(Window)에 포함되는 모든 패킷을 전송하고, 수신 측은 패킷을 받았다는 ACK를 보낸다.
       - 이때 Time 안에 각 패킷에 대한 ACK가 오지 않으면 ACK를 받지 못한 패킷에 대해 재전송을 한다.
    2. 송신 측은 자신이 전송한 가장 마지막 패킷의 번호와 가장 최근에 받은 ACK의 번호를 기억하며, 패킷의 전달이 확인되면 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.
       - 이때 수신 측에서 데이터를 읽는 속도가 떨어질 경우, WS(Window Size)를 줄여가며 송신 측의 데이터 전송을 컨트롤 한다.

</br>

## 혼잡제어(Congestion Control)

> 호스트(송신 측의 데이터 전달)와 네트워크상의 데이터처리 속도 차이를 해결하기 위한 기법이다.

- 송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 이때 한 라우더에 데이터가 몰려 혼잡해질 경우 라우터는 자신에게 온 데이터를 모두 처리할 수 없다. 그렇게 되면 호스트들은 데이터를 재전송하게 되고 결국 혼잡을 가중시켜 overflow나 데이터 손실을 발생시킨다. 이러한 네트워크의 혼잡을 피하고자 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이게 되는데, 이 작업을 혼잡제어라고 한다.

* 흐름제어가 송신 측과 수신 측 사이의 전송속도를 다뤘다면, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다룬다.

### 1. AIMD

- 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window size를 1씩 증가시켜가며 전송하는 방법이다.

* 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄인다.
* 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리며, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 단점이 있다.

### 2. Slow start

- AIDM 처럼 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 따라서 한 주기가 지나면 window size가 2배로 된다.

* 혼잡 현상이 발생하면 window size를 1로 떨어뜨린다.
* 한 번 혼잡 현상을 겪고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으며, 혼잡현상이 발생했던 창 크기의 절반까지는 이전처럼 지수함수 꼴로(주기가 지날 때마다 2배씩 증가) 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.

### 3. Fast Retransmit (빠른 재전송)

- 수신 측은 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다.
- 따라서 중간에 손실되는 패킷이 발생하여 수신 측에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 이때 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다.
- 중복된 순번의 패킷을 3개 받으면 재전송한다. 또한 혼잡을 감지하고 window size를 줄이게 된다.

### 4. Fast Recovery (빠른 회복)

- 혼잡한 상태가 되면 window의 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다.

* 혼잡 상황을 한 번 겪고 나면 순수한 AIMD 방식으로 동작한다.
